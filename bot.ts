import 'dotenv/config';
import mongoose from 'mongoose';
import { Bot, GrammyError, HttpError, InlineKeyboard, session } from 'grammy';
import { User as TelegramUser } from '@grammyjs/types';
import { hydrate } from '@grammyjs/hydrate';
import { conversations, createConversation } from '@grammyjs/conversations';
import { limit } from '@grammyjs/ratelimiter';
import {
  MyContext,
  AiModelsLabels,
  ImageGenerationQuality,
  SessionData,
  AiModels,
  PackageName,
} from './src/types/types';
import {
  isValidAiModel,
  isValidImageGenerationQuality,
} from './src/types/typeguards';
import User from './db/User';
import Chat from './db/Chat';
import Message from './db/Message';
import { answerWithChatGPT } from './src/utils/gpt';
import {
  getBalanceMessage,
  getNoBalanceMessage,
  HELP_MESSAGE,
  MAX_HISTORY_LENGTH,
} from './src/utils/consts';
import {
  start,
  getStats,
  initiateAiModelChange,
  topupImg,
  topupText,
  createNewChat,
  checkSubscriptionAndRegisterUser,
} from './src/commands';
import {
  topupAndChangeModelKeyboard,
  initiateTopupKeyboard,
} from './src/commands/topup';
import { getModelsKeyboard } from './src/commands/changeAiModel';
import { imageConversation } from './src/conversations/imageConversation';
import { supportConversation } from './src/conversations/supportConversation';
import { createPaymentConversation } from './src/conversations/createPaymentConversation';
import { PACKAGES } from './src/bot-packages';
import { checkUserInDB, ignoreOld } from './src/utils/middleware';
import {
  logError,
  getBotApiKey,
  getMongoDbUri,
} from './src/utils/utilFunctions';
import { telegramSuccessfulPaymentHandler } from './src/utils/payments';

const BOT_API_KEY = getBotApiKey();

if (!BOT_API_KEY) {
  throw new Error('BOT_API_KEY is not defined');
}

const bot = new Bot<MyContext>(BOT_API_KEY);

bot.on('pre_checkout_query', async (ctx) => {
  await ctx.answerPreCheckoutQuery(true);
});

bot.use(
  session({
    initial: (): SessionData => ({
      imageQuality: ImageGenerationQuality.STANDARD,
    }),
  }),
);
bot.use(hydrate());
bot.use(conversations());

bot.use(ignoreOld);

bot.use(
  limit({
    timeFrame: 2000,
    limit: 3,
    onLimitExceeded: async (ctx) => {
      await ctx.reply(
        '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –∑–∞–ø—Ä–æ—Å—ã —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ. –ü–æ–¥–æ–∂–¥–∏—Ç–µ 5 —Å–µ–∫—É–Ω–¥ –∏ –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.',
      );
    },
  }),
);

bot.use(checkUserInDB);

// Conversations
bot.use(createConversation(imageConversation));
bot.use(createConversation(supportConversation));
bot.use(createConversation(createPaymentConversation));

void bot.api.setMyCommands([
  {
    command: 'balance',
    description: 'üè¶ –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å –∑–∞–ø—Ä–æ—Å–æ–≤',
  },
  {
    command: 'topup',
    description: 'üí∞ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å',
  },
  {
    command: 'newchat',
    description: 'üí¨ –ù–∞—á–∞—Ç—å –Ω–æ–≤—ã–π —á–∞—Ç',
  },
  {
    command: 'image',
    description: 'üñºÔ∏è –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ',
  },
  {
    command: 'models',
    description: 'ü§ñ –í—ã–±—Ä–∞—Ç—å AI-–º–æ–¥–µ–ª—å',
  },
  {
    command: 'help',
    description: '‚ÑπÔ∏è –û–±—â–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è',
  },
  {
    command: 'support',
    description: 'üÜò –û–±—Ä–∞—Ç–∏—Ç—å—Å—è –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É',
  },
]);

bot.on(':successful_payment', telegramSuccessfulPaymentHandler);

// Callback queries
bot.callbackQuery(
  'checkSubscriptionAndRegisterUser',
  checkSubscriptionAndRegisterUser,
);
bot.callbackQuery(Object.keys(AiModelsLabels), async (ctx) => {
  await ctx.answerCallbackQuery();
  const selectedModel = ctx.callbackQuery.data;
  const { id } = ctx.from;

  if (!isValidAiModel(selectedModel)) {
    await ctx.callbackQuery.message?.editText(
      '–ù–µ–≤–µ—Ä–Ω–∞—è –º–æ–¥–µ–ª—å. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –º–æ–¥–µ–ª—å.',
    );
    return;
  }

  try {
    const user = await User.findOne({ telegramId: id });
    if (!user) {
      await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Å –∫–æ–º–∞–Ω–¥—ã /start.');
      return;
    }

    user.selectedModel = selectedModel;
    user.updatedAt = new Date();
    await user.save();

    const messagePostfix =
      AiModels[selectedModel] === AiModels.GPT_4O ? '' : ' (–±–∞–∑–æ–≤—ã–µ –∑–∞–ø—Ä–æ—Å—ã) ';

    await ctx.callbackQuery.message?.editText(
      `–í—ã –ø–µ—Ä–µ–∫–ª—é—á–∏–ª–∏—Å—å –Ω–∞ –º–æ–¥–µ–ª—å\n${AiModelsLabels[selectedModel]}${messagePostfix} ‚úÖ`,
      {
        reply_markup: getModelsKeyboard(AiModelsLabels[selectedModel]),
      },
    );
  } catch (error) {
    await ctx.reply(
      '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –º–æ–¥–µ–ª–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.',
    );
    logError({
      message: 'Error in callbackQuery handler',
      error,
      telegramId: id,
      username: ctx.from.username,
    });
  }
});
bot.callbackQuery('cancelImageGeneration', async (ctx) => {
  await ctx.answerCallbackQuery('–û—Ç–º–µ–Ω–µ–Ω–æ ‚úÖ');
  await ctx.conversation.exit('imageConversation');
  await ctx.callbackQuery.message?.editText('–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞');
});
bot.callbackQuery('cancelSupport', async (ctx) => {
  await ctx.answerCallbackQuery('–û—Ç–º–µ–Ω–µ–Ω–æ ‚úÖ');
  await ctx.conversation.exit('supportConversation');
  await ctx.callbackQuery.message?.editText('–ó–∞–ø—Ä–æ—Å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É –æ—Ç–º–µ–Ω–µ–Ω');
});
bot.callbackQuery('cancelPayment', async (ctx) => {
  await ctx.answerCallbackQuery('–û—Ç–º–µ–Ω–µ–Ω–æ ‚úÖ');
  await ctx.conversation.exit('createPaymentConversation');
  await ctx.callbackQuery.message?.editText('–û–ø–ª–∞—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞');
});
bot.callbackQuery(Object.values(ImageGenerationQuality), async (ctx) => {
  await ctx.answerCallbackQuery();
  const quality = ctx.callbackQuery.data;
  if (!isValidImageGenerationQuality(quality)) {
    await ctx.callbackQuery.message?.editText(
      '–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.',
    );
    return;
  }
  ctx.session.imageQuality = quality;
  await ctx.callbackQuery.message?.editText(`–í—ã–±—Ä–∞–Ω–æ –∫–∞—á–µ—Å—Ç–≤–æ: ${quality}`);

  await ctx.conversation.enter('imageConversation');
});
// Here you can enter createPaymentConversation or pass createInvoice function
bot.callbackQuery(Object.keys(PACKAGES), async (ctx) => {
  await ctx.answerCallbackQuery();
  await ctx.callbackQuery.message?.editReplyMarkup(undefined);
  ctx.session.packageName = ctx.callbackQuery.data as PackageName;
  await ctx.conversation.enter('createPaymentConversation');
});
bot.callbackQuery('topupText', topupText);
bot.callbackQuery('topup', topupImg);
bot.callbackQuery('initiateAiModelChange', initiateAiModelChange);

// User commands
bot.command('start', start);
bot.command('help', async (ctx) => {
  await ctx.reply(HELP_MESSAGE, {
    parse_mode: 'MarkdownV2',
  });
});
bot.command('newchat', createNewChat);
bot.command('image', async (ctx) => {
  if (process.env.IMAGE_QUALITY_CHANGE_AVAILABLE === 'false') {
    await ctx.conversation.enter('imageConversation');
    return;
  }
  const qualityKeyboard = new InlineKeyboard()
    .text('Standard', ImageGenerationQuality.STANDARD)
    .text('HD', ImageGenerationQuality.HD)
    .row()
    .text('–û—Ç–º–µ–Ω–∏—Ç—å ‚ùå', 'cancelImageGeneration');

  await ctx.reply(
    `–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—á–µ—Å—Ç–≤–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:
    standard ‚Äî —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ
    hd ‚Äî –ø–æ–≤—ã—à–µ–Ω–Ω–∞—è –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è`,
    {
      reply_markup: qualityKeyboard,
    },
  );
});
bot.command('models', initiateAiModelChange);
bot.command('balance', async (ctx) => {
  const { id } = ctx.from as TelegramUser;

  try {
    const user = await User.findOne({ telegramId: id });
    if (!user) {
      await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Å –∫–æ–º–∞–Ω–¥—ã /start.');
      return;
    }

    await ctx.reply(getBalanceMessage(user), {
      parse_mode: 'MarkdownV2',
      reply_markup: initiateTopupKeyboard,
    });
  } catch (error) {
    await ctx.reply(
      '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.',
    );
    logError({
      message: 'Error in /balance command',
      error,
      telegramId: ctx.from?.id,
      username: ctx.from?.username,
    });
  }
});
bot.command('topup', topupImg);
bot.command('support', async (ctx) => {
  await ctx.conversation.enter('supportConversation');
});

// Admin commands
bot.command('stats', getStats);

// Message handler
bot.on('message:text', async (ctx) => {
  let chatId = ctx.session.chatId;
  let chatObj;
  const telegramId = ctx.from.id;
  const userMessageText = ctx.message.text;

  if (userMessageText.length > 3000) {
    await ctx.reply(
      '–ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–æ–∫—Ä–∞—Ç–∏—Ç–µ –í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.',
    );
    return;
  }

  const responseMessage = await ctx.reply('–ó–∞–≥—Ä—É–∑–∫–∞...');

  try {
    const user = await User.findOne({ telegramId });
    if (!user) {
      await responseMessage.editText(
        '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π —á–∞—Ç —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /start.',
      );
      return;
    }

    if (!chatId) {
      const latestChat = await Chat.findOne({ userId: user._id }).sort({
        createdAt: -1,
      });
      if (latestChat) {
        chatObj = latestChat;
        chatId = latestChat._id.toString();
        ctx.session.chatId = chatId;
      } else {
        await responseMessage.editText(
          '–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π —á–∞—Ç —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /start.',
        );
        return;
      }
    }

    const chat = chatObj || (await Chat.findById(chatId));
    if (!chat) {
      await ctx.reply(
        '–ß–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –Ω–æ–≤—ã–π —á–∞—Ç —Å –ø–æ–º–æ—â—å—é –∫–æ–º–∞–Ω–¥—ã /start.',
      );
      return;
    }

    if (AiModels[user.selectedModel] === AiModels.GPT_4O) {
      if (user.proRequestsBalance === 0) {
        await responseMessage.editText(
          getNoBalanceMessage(user.selectedModel),
          {
            reply_markup: topupAndChangeModelKeyboard,
          },
        );
        return;
      }
    } else {
      if (user.basicRequestsBalance === 0) {
        await responseMessage.editText(
          getNoBalanceMessage(user.selectedModel),
          {
            reply_markup: topupAndChangeModelKeyboard,
          },
        );
        return;
      }
    }

    await Message.create({
      chatId: chat._id,
      userId: user._id,
      role: 'user',
      content: userMessageText,
    });

    const messages = await Message.find({ chatId: chat._id })
      .sort({ createdAt: 1 })
      .lean();

    const history = messages.slice(-MAX_HISTORY_LENGTH);
    const selectedModelName = user.selectedModel;
    const answer = await answerWithChatGPT(
      history,
      telegramId,
      selectedModelName,
    );

    if (!answer) {
      await responseMessage.editText(
        '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.',
      );
      return;
    }

    await Message.create({
      chatId: chat._id,
      userId: user._id,
      role: 'assistant',
      content: answer,
    });

    await chat.save();

    if (AiModels[user.selectedModel] === AiModels.GPT_4O) {
      user.proRequestsBalance -= 1;
    } else {
      user.basicRequestsBalance -= 1;
    }
    user.updatedAt = new Date();
    await user.save();

    await responseMessage.editText(answer);
  } catch (error) {
    await responseMessage.editText(
      '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.',
    );
    logError({
      message: 'Error in message handler',
      error,
      telegramId: ctx.from?.id,
      username: ctx.from?.username,
    });
  }
});

// Updated catch handler
bot.catch(async (err) => {
  const ctx = err.ctx;
  logError({
    message: `Error while handling update ${ctx.update.update_id}`,
    error: err.error,
    telegramId: ctx.from?.id,
    username: ctx.from?.username,
  });
  const e = err.error;
  let message;

  if (e instanceof GrammyError) {
    message = 'Error in request';
  } else if (e instanceof HttpError) {
    message = 'Could not contact Telegram';
  } else {
    message = 'Unknown error';
  }
  logError({
    message,
    error: e,
    telegramId: ctx.from?.id,
    username: ctx.from?.username,
  });

  try {
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  } catch (replyError) {
    logError({
      message: 'Failed to send error message to user in bot.catch',
      error: replyError,
      telegramId: ctx.from?.id,
      username: ctx.from?.username,
    });
  }
});

async function startBot() {
  try {
    const mongoDbUri = getMongoDbUri();
    if (!mongoDbUri) {
      throw new Error('MONGO_DB_URI is not defined');
    }
    const mongooseResponse = await mongoose.connect(mongoDbUri);
    if (!mongooseResponse.connection.readyState) {
      throw new Error('Mongoose connection error');
    }
    void bot.start();
    // eslint-disable-next-line no-console
    console.log('Mongoose connected & bot started');
  } catch (error) {
    const err = error as Error;
    logError({
      message: 'Error in startBot',
      error: err,
    });
  }
}

void startBot();

export default bot;
